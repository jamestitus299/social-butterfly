{"version":3,"names":["_core","require","_assert","_helperAnnotateAsPure","ENUMS","WeakMap","buildEnumWrapper","template","expression","transpileEnum","path","t","node","parentPath","declare","remove","name","id","fill","data","isPure","enumFill","type","isGlobal","isProgram","parent","isSeen","seen","init","objectExpression","logicalExpression","cloneNode","ID","enumIIFE","Object","assign","INIT","annotateAsPure","toReplace","isExportDeclaration","replaceWith","expressionStatement","assignmentExpression","scope","registerDeclaration","variableDeclaration","variableDeclarator","set","getBindingIdentifier","Error","getData","setData","buildStringAssignment","buildNumericAssignment","buildEnumMember","isString","options","enumValues","x","translateEnumValues","assignments","map","memberName","memberValue","isStringLiteral","ENUM","NAME","VALUE","ASSIGNMENTS","ReferencedIdentifier","expr","state","has","hasOwnBinding","memberExpression","skip","enumSelfReferenceVisitor","Map","constValue","lastName","get","memberPath","member","isIdentifier","value","initializerPath","initializer","computeConstantValue","undefined","numericLiteral","assert","stringLiteral","isReferencedIdentifier","traverse","buildCodeFrameError","lastRef","binaryExpression","prevMembers","Set","evaluate","evaluateRef","evalUnaryExpression","evalBinaryExpression","quasis","length","cooked","paths","str","i","isMemberExpression","obj","object","prop","property","computed","bindingIdentifier","bindingInitPath","resolve","add","operator","left","right","Math","pow"],"sources":["../src/enum.ts"],"sourcesContent":["import { template, types as t } from \"@babel/core\";\nimport type { NodePath } from \"@babel/traverse\";\nimport assert from \"assert\";\nimport annotateAsPure from \"@babel/helper-annotate-as-pure\";\n\ntype t = typeof t;\n\nconst ENUMS = new WeakMap<t.Identifier, PreviousEnumMembers>();\n\nconst buildEnumWrapper = template.expression(\n  `\n    (function (ID) {\n      ASSIGNMENTS;\n      return ID;\n    })(INIT)\n  `,\n);\n\nexport default function transpileEnum(\n  path: NodePath<t.TSEnumDeclaration>,\n  t: t,\n) {\n  const { node, parentPath } = path;\n\n  if (node.declare) {\n    path.remove();\n    return;\n  }\n\n  const name = node.id.name;\n  const { fill, data, isPure } = enumFill(path, t, node.id);\n\n  switch (parentPath.type) {\n    case \"BlockStatement\":\n    case \"ExportNamedDeclaration\":\n    case \"Program\": {\n      // todo: Consider exclude program with import/export\n      // && !path.parent.body.some(n => t.isImportDeclaration(n) || t.isExportDeclaration(n));\n      const isGlobal = t.isProgram(path.parent);\n      const isSeen = seen(parentPath);\n\n      let init: t.Expression = t.objectExpression([]);\n      if (isSeen || isGlobal) {\n        init = t.logicalExpression(\"||\", t.cloneNode(fill.ID), init);\n      }\n      const enumIIFE = buildEnumWrapper({ ...fill, INIT: init });\n      if (isPure) annotateAsPure(enumIIFE);\n\n      if (isSeen) {\n        const toReplace = parentPath.isExportDeclaration() ? parentPath : path;\n        toReplace.replaceWith(\n          t.expressionStatement(\n            t.assignmentExpression(\"=\", t.cloneNode(node.id), enumIIFE),\n          ),\n        );\n      } else {\n        path.scope.registerDeclaration(\n          path.replaceWith(\n            t.variableDeclaration(isGlobal ? \"var\" : \"let\", [\n              t.variableDeclarator(node.id, enumIIFE),\n            ]),\n          )[0],\n        );\n      }\n      ENUMS.set(path.scope.getBindingIdentifier(name), data);\n      break;\n    }\n\n    default:\n      throw new Error(`Unexpected enum parent '${path.parent.type}`);\n  }\n\n  function seen(parentPath: NodePath<t.Node>): boolean {\n    if (parentPath.isExportDeclaration()) {\n      return seen(parentPath.parentPath);\n    }\n\n    if (parentPath.getData(name)) {\n      return true;\n    } else {\n      parentPath.setData(name, true);\n      return false;\n    }\n  }\n}\n\nconst buildStringAssignment = template(`\n  ENUM[\"NAME\"] = VALUE;\n`);\n\nconst buildNumericAssignment = template(`\n  ENUM[ENUM[\"NAME\"] = VALUE] = \"NAME\";\n`);\n\nconst buildEnumMember = (isString: boolean, options: Record<string, unknown>) =>\n  (isString ? buildStringAssignment : buildNumericAssignment)(options);\n\n/**\n * Generates the statement that fills in the variable declared by the enum.\n * `(function (E) { ... assignments ... })(E || (E = {}));`\n */\nfunction enumFill(path: NodePath<t.TSEnumDeclaration>, t: t, id: t.Identifier) {\n  const { enumValues: x, data, isPure } = translateEnumValues(path, t);\n  const assignments = x.map(([memberName, memberValue]) =>\n    buildEnumMember(t.isStringLiteral(memberValue), {\n      ENUM: t.cloneNode(id),\n      NAME: memberName,\n      VALUE: memberValue,\n    }),\n  );\n\n  return {\n    fill: {\n      ID: t.cloneNode(id),\n      ASSIGNMENTS: assignments,\n    },\n    data,\n    isPure,\n  }