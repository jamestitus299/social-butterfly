'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _createForOfIteratorHelperLoose = require('@babel/runtime/helpers/createForOfIteratorHelperLoose');
var _extends = require('@babel/runtime/helpers/extends');
var _objectWithoutPropertiesLoose = require('@babel/runtime/helpers/objectWithoutPropertiesLoose');
var nodePath = require('path');
var sourceMap = require('source-map');
var convert = require('convert-source-map');
var findRoot = require('find-root');
var memoize = require('@emotion/memoize');
var hashString = require('@emotion/hash');
var escapeRegexp = require('escape-string-regexp');
var serialize = require('@emotion/serialize');
var stylis = require('stylis');
var helperModuleImports = require('@babel/helper-module-imports');
var babelPluginMacros = require('babel-plugin-macros');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var nodePath__default = /*#__PURE__*/_interopDefault(nodePath);
var convert__default = /*#__PURE__*/_interopDefault(convert);
var findRoot__default = /*#__PURE__*/_interopDefault(findRoot);
var memoize__default = /*#__PURE__*/_interopDefault(memoize);
var hashString__default = /*#__PURE__*/_interopDefault(hashString);
var escapeRegexp__default = /*#__PURE__*/_interopDefault(escapeRegexp);

var invalidClassNameCharacters = /[!"#$%&'()*+,./:;<=>?@[\]^`|}~{]/g;

var sanitizeLabelPart = function sanitizeLabelPart(labelPart) {
  return labelPart.trim().replace(invalidClassNameCharacters, '-');
};

function getLabel(identifierName, labelFormat, filename) {
  if (!identifierName) return null;
  var sanitizedName = sanitizeLabelPart(identifierName);

  if (!labelFormat) {
    return sanitizedName;
  }

  if (typeof labelFormat === 'function') {
    return labelFormat({
      name: sanitizedName,
      path: filename
    });
  }

  var parsedPath = nodePath__default["default"].parse(filename);
  var localDirname = nodePath__default["default"].basename(parsedPath.dir);
  var localFilename = parsedPath.name;

  if (localFilename === 'index') {
    localFilename = localDirname;
  }

  return labelFormat.replace(/\[local\]/gi, sanitizedName).replace(/\[filename\]/gi, sanitizeLabelPart(localFilename)).replace(/\[dirname\]/gi, sanitizeLabelPart(localDirname));
}

function getLabelFromPath(path, state, t) {
  return getLabel(getIdentifierName(path, t), state.opts.labelFormat, state.file.opts.filename);
}

var getObjPropertyLikeName = function getObjPropertyLikeName(path, t) {
  if (!t.isObjectProperty(path) && !t.isObjectMethod(path) || path.node.computed) {
    return null;
  }

  if (t.isIdentifier(path.node.key)) {
    return path.node.key.name;
  }

  if (t.isStringLiteral(path.node.key)) {
    return path.node.key.value.replace(/\s+/g, '-');
  }

  return null;
};

function getDeclaratorName(path, t) {
  // $FlowFixMe
  var parent = path.findParent(function (p) {
    return p.isVariableDeclarator() || p.isAssignmentExpression() || p.isFunctionDeclaration() || p.isFunctionExpression() || p.isArrowFunctionExpression() || p.isObjectProperty() || p.isObjectMethod();
  });

  if (!parent) {
    return '';
  } // we probably have a css call assigned to a variable
  // so we'll just return the variable name


  if (parent.isVariableDeclarator()) {
    if (t.isIdentifier(parent.node.id)) {
      return parent.node.id.name;
    }

    return '';
  }

  if (parent.isAssignmentExpression()) {
    var left = parent.node.left;

    if (t.isIdentifier(left)) {
      return left.name;
    }

    if (t.isMemberExpression(left)) {
      var memberExpression = left;
      var name = '';

      while (true) {
        if (!t.isIdentifier(memberExpression.property)) {
          return '';
        }

        name = "" + memberExpression.property.name + (name ? "-" + name : '');

        if (t.isIdentifier(memberExpression.object)) {
          return memberExpression.object.name + "-" + name;
        }

        if (!t.isMemberExpression(memberExpression.object)) {
          return '';
        }

        memberExpression = memberExpression.object;
      }
    }

    return '';
  } // we probably have an inline css prop usage


  if (parent.isFunctionDeclaration()) {
    return parent.node.id.name || '';
  }

  if (parent.isFunctionExpression()) {
    if (parent.node.id) {
      return parent.node.id.name || '';
    }

    return getDeclaratorName(parent, t);
  }

  if (parent.isArrowFunctionExpression()) {
    return getDeclaratorName(parent, t);
  } // we could also have an object property


  var objPropertyLikeName = getObjPropertyLikeName(parent, t);

  if (objPropertyLikeName) {
    return objPropertyLikeName;
  }

  var variableDeclarator = parent.findParent(function (p) {
    return p.isVariableDeclarator();
  });

  if (!variableDeclarator || !variableDeclarator.get('id').isIdentifier()) {
    return '';
  }

  return variableDeclarator.node.id.name;
}

function getIdentifierName(path, t) {
  var objPropertyLikeName = getObjPropertyLikeName(path.parentPath, t);

  if (objPropertyLikeName) {
    return objPropertyLikeName;
  } // $FlowFixMe


  var classOrClassPropertyParent = path.findParent(function (p) {
    return t.isClassProperty(p) || t.isClass(p);
  });

  if (classOrClassPropertyParent) {
    if (t.isClassProperty(classOrClassPropertyParent) && classOrClassPropertyParent.node.computed === false && t.isIdentifier(classOrClassPropertyParent.node.key)) {
      return classOrClassPropertyParent.node.key.name;
    }

    if (t.isClass(classOrClassPropertyParent) && classOrClassPropertyParent.node.id) {
      return t.isIdentifier(classOrClassPropertyParent.node.id) ? classOrClassPropertyParent.node.id.name : '';
    }
  }

  var declaratorName = getDeclaratorName(path, t); // if the name starts with _ it was probably generated by babel so we should ignore it

  if (declaratorName.charAt(0) === '_') {
    return '';
  }

  return declaratorName;
}

function getGeneratorOpts(file) {
  return file.opts.generatorOpts ? file.opts.generatorOpts : file.opts;
}

function makeSourceMapGenerator(file) {
  var generatorOpts = getGeneratorOpts(file);
  var filename = generatorOpts.sourceFileName;
  var generator = new sourceMap.SourceMapGenerator({
    file: filename,
    sourceRoot: generatorOpts.sourceRoot
  });
  generator.setSourceContent(filename, file.code);
  return generator;
}
function getSourceMap(offset, state) {
  var generator = makeSourceMapGenerator(state.file);
  var generatorOpts = getGeneratorOpts(state.file);

  if (generatorOpts.sourceFileName && generatorOpts.sourceFileName !== 'unknown') {
    generator.addMapping({
      generated: {
        line: 1,
        column: 0
      },
      source: generatorOpts.sourceFileName,
      original: offset
    });
    return convert__default["default"].fromObject(generator).toComment({
      multiline: true
    });
  }

  return '';
}

var hashArray = function hashArray(arr) {
  return hashString__default["default"](arr.join(''));
};

var unsafeRequire = require;
var getPackageRootPath = memoize__default["default"](function (filename) {
  return findRoot__default["default"](filename);
});
var separator = new RegExp(escapeRegexp__default["default"](nodePath__default["default"].sep), 'g');

var normalizePath = function normalizePath(path) {
  return nodePath__default["default"].normalize(path).replace(separator, '/');
};

function getTargetClassName(state, t) {
  if (state.emotionTargetClassNameCount === undefined) {
    state.emotionTargetClassNameCount = 0;
  }

  var hasFilepath = state.file.opts.filename && state.file.opts.filename !== 'unknown';
  var filename = hasFilepath ? state.file.opts.filename : ''; // normalize the file path to ignore folder structure
  // outside the current node project and arch-specific delimiters

  var moduleName = '';
  var rootPath = filename;

  try {
    rootPath = getPackageRootPath(filename);
    moduleName = unsafeRequire(rootPath + '/package.json').name;
  } catch (err) {}

  var finalPath = filename === rootPath ? 'root' : filename.slice(rootPath.length);
  var positionInFile = state.emotionTargetClassNameCount++;
  var stuffToHash = [moduleName];

  if (finalPath) {
    stuffToHash.push(normalizePath(finalPath));
  } else {
    stuffToHash.push(state.file.code);
  }

  var stableClassName = "e" + hashArray(stuffToHash) + positionInFile;
  return stableClassName;
}

// it's meant to simplify the most common cases so i don't want to make it especially complex
// also, this will be unnecessary when prepack is ready

function simplifyObject(node, t) {
  var finalString = '';

  for (var i = 0; i < node.properties.length; i++) {
    var _ref;

    var property = node.properties[i];

    if (!t.isObjectProperty(property) || property.computed || !t.isIdentifier(property.key) && !t.isStringLiteral(property.key) || !t.isStringLiteral(property.value) && !t.isNumericLiteral(property.value) && !t.isObjectExpression(property.value)) {
      return node;
    }

    var key = property.key.name || property.key.value;

    if (key === 'styles') {
      return node;
    }

    if (t.isObjectExpression(property.value)) {
      var simplifiedChild = simplifyObject(property.value, t);

      if (!t.isStringLiteral(simplifiedChild)) {
        return node;
      }

      finalString += key + "{" + simplifiedChild.value + "}";
      continue;
    }

    var value = property.value.value;
    finalString += serialize.serializeStyles([(_ref = {}, _ref[key] = value, _ref)]).styles;
  }

  return t.stringLiteral(finalString);
}

var haveSameLocation = function haveSameLocation(element1, element2) {
  return element1.line === element2.line && element1.column === element2.column;
};

var isAutoInsertedRule = function isAutoInsertedRule(element) {
  return element.type === 'rule' && element.parent && haveSameLocation(element, element.parent);
};

var toInputTree = function toInputTree(elements, tree) {
  for (var i = 0; i < elements.length; i++) {
    var element = elements[i];
    var parent = element.parent,
        children = element.children;

    if (!parent) {
      tree.push(element);
    } else if (!isAutoInsertedRule(element)) {
      parent.children.push(element);
    }

    if (Array.isArray(children)) {
      element.children = [];
      toInputTree(children, tree);
    }
  }

  return tree;
};

var stringifyTree = function stringifyTree(elements) {
  return elements.map(function (element) {
    switch (element.type) {
      case 'import':
      case 'decl':
        return element.value;

      case 'comm':
        // When we encounter a standard multi-line CSS comment and it contains a '@'
        // character, we keep the comment. Some Stylis plugins, such as
        // the stylis-rtl via the cssjanus plugin, use this special comment syntax
        // to control behavior (such as: /* @noflip */). We can do this
        // with standard CSS comments because they will work with compression,
        // as opposed to non-standard single-line comments that will break compressed CSS.
        return element.props === '/' && element.value.includes('@') ? element.value : '';

      case 'rule':
        return element.value.replace(/&\f/g, '&') + "{" + stringifyTree(element.children) + "}";

      default:
        {
          return element.value + "{" + stringifyTree(element.children) + "}";
        }
    }
  }).join('');
};

var interleave = function interleave(strings, interpolations) {
  return interpolations.reduce(function (array, interp, i) {
    return array.concat([interp], strings[i + 1]);
  }, [strings[0]]);
};

function getDynamicMatches(str) {
  var re = /xxx(\d+):xxx/gm;
  var match;
  var matches = [];

  while ((match = re.exec(str)) !== null) {
    // so that flow doesn't complain
    if (match !== null) {
      matches.push({
        value: match[0],
        p1: parseInt(match[1], 10),
        index: match.index
      });
    }
  }

  return matches;
}

function replacePlaceholdersWithExpressions(str, expressions, t) {
  var matches = getDynamicMatches(str);

  if (matches.length === 0) {
    if (str === '') {
      return [];
    }

    return [t.stringLiteral(str)];
  }

  var strings = [];
  var finalExpressions = [];
  var cursor = 0;
  matches.forEach(function (_ref, i) {
    var value = _ref.value,
        p1 = _ref.p1,
        index = _ref.index;
    var preMatch = str.substring(cursor, index);
    cursor = cursor + preMatch.length + value.length;

    if (!preMatch && i === 0) {
      strings.push(t.stringLiteral(''));
    } else {
      strings.push(t.stringLiteral(preMatch));
    }

    finalExpressions.push(expressions[p1]);

    if (i === matches.length - 1) {
      strings.push(t.stringLiteral(str.substring(index + value.length)));
    }
  });
  return interleave(strings, finalExpressions).filter(function (node) {
    return node.value !== '';
  });
}

function createRawStringFromTemplateLiteral(quasi) {
  var strs = quasi.quasis.map(function (x) {
    return x.value.cooked;
  });
  var src = strs.reduce(function (arr, str, i) {
    arr.push(str);

    if (i !== strs.length - 1) {
      arr.push("xxx" + i + ":xxx");
    }

    return arr;
  }, []).join('').trim();
  return src;
}

function minify(path, t) {
  var quasi = path.node.quasi;
  var raw = createRawStringFromTemplateLiteral(quasi);
  var minified = stringifyTree(toInputTree(stylis.compile(raw), []));
  var expressions = replacePlaceholdersWithExpressions(minified, quasi.expressions || [], t);
  path.replaceWith(t.callExpression(path.node.tag, expressions));
}

// this only works correctly in modules, but we don't run on scripts anyway, so it's fine
// the difference is that in modules template objects are being cached per call site
function getTypeScriptMakeTemplateObjectPath(path) {
  if (path.node.arguments.length === 0) {
    return null;
  }

  var firstArgPath = path.get('arguments')[0];

  if (firstArgPath.isLogicalExpression() && firstArgPath.get('left').isIdentifier() && firstArgPath.get('right').isAssignmentExpression() && firstArgPath.get('right.right').isCallExpression() && firstArgPath.get('right.right.callee').isIdentifier() && firstArgPath.node.right.right.callee.name.includes('makeTemplateObject') && firstArgPath.node.right.right.arguments.length === 2) {
    return firstArgPath.get('right.right');
  }

  return null;
} // this is only used to prevent appending strings/expressions to arguments incorectly
// we could push them to found array expressions, as we do it for TS-transpile output ¯\_(ツ)_/¯
// it seems overly complicated though - mainly because we'd also have to check against existing stuff of a particular type (source maps & labels)
// considering Babel double-transpilation as a valid use case seems rather far-fetched

function isTaggedTemplate